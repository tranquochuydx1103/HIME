
Tóm tắt Phát hiện các mẫu có độ dài thay đổi lặp đi lặp lại, còn được gọi là họa tiết có độ dài thay đổi, đã nhận được rất nhiều sự chú ý trong những năm gần đây. Thuật toán hiện đại sử dụng thuật toán khám phá mô-đun có độ dài như một chương trình con để liệt kê các họa tiết có độ dài thay đổi. Do đó, có thể mất hàng giờ hoặc nhiều ngày để thực thi khi phạm vi liệt kê lớn. Trong tác phẩm này, weint sinheanapproimumateal ThuậtmcalledHVELIcalbasing Motif Enumutions (HIME) để phát hiện các họa tiết có độ dài thay đổi với phạm vi liệt kê lớn trong chuỗi thời gian hàng triệu. Chúng tôi cho thấy trong các thí nghiệm rằng khả năng mở rộng của thuật toán được đề xuất là tốt hơn đáng kể so với thuật toán hiện đại. Ngoài ra, phạm vi chiều dài mô-đun được HIME phát hiện lớn hơn đáng kể so với phương pháp tiếp cận khám phá mô-đun độ dài biến đổi gần đúng theo trình tự trước đó. Chúng tôi chứng minh rằng HIME có thể phát hiện thường xuyên các họa tiết có chiều dài thay đổi có ý nghĩa trong chuỗi thời gian thực dài. I. GIỚI THIỆU Nhiệm vụ của các mẫu tương tự lặp đi lặp lại trong dữ liệu chuỗi thời gian, được gọi là khám phá mô-đun, đã nhận được rất nhiều sự chú ý trong thập kỷ qua. Nó đã được sử dụng như một chương trình con quan trọng trong nhiều nhiệm vụ và ứng dụng khai thác dữ liệu theo chuỗi thời gian như khai thác quy tắc kết hợp [27], trực quan hóa dữ liệu [26], phân loại [30], phân cụm [3], phát hiện bất thường [26] [8] và công nhận hoạt động [15]. Hầu hết các thuật toán khám phá mô-đun hiện có [5] [20] [11] [12] coi độ dài của họa tiết là kiến ​​thức miền quan trọng cần được xác định bởi người dùng [32]. Chúng tôi lập luận rằng các mô típ khác nhau, độ dài chưa biết trước đó là một chủ đề được đề cập nhiều trong tài liệu. Đây là một trở ngại đáng kể ngăn cản các họa tiết đạt được tiềm năng đầy đủ của chúng như là một khai thác dữ liệu chuỗi thời gian hữu ích. Để chứng minh những hạn chế của việc phát hiện họa tiết có chiều dài, chúng tôi đưa ra một ví dụ về một tập hợp con của chuỗi thời gian nhu cầu năng lượng điện của máy rửa chén (Hình 1.top). Một chu trình giặt cơ bản mất khoảng nửa giờ (khoảng 350 điểm mẫu). Bằng cách đặt độ dài họa tiết bằng một chu kỳ cơ bản, chúng ta có thể tìm thấy một mẫu lặp lại thường xuyên, đại diện cho một chu trình giặt, như trong Hình 1 (Motif A). Tuy nhiên, sau khi chạy thuật toán của chúng tôi, chúng tôi cũng tìm thấy một mô-đun thường xuyên (Motif B) có độ dài 1534 (khoảng 2,5 giờ) và một mô-đun hiếm (Motif C) có chiều dài 2791 (khoảng 4,6 giờ) chỉ xảy ra một vài lần trong chuỗi thời gian. Việc phát hiện ra hai họa tiết dài này là đáng ngạc nhiên với độ dài tương ứng của chúng 
so với chu trình giặt cơ bản. Vì độ dài của ba họa tiết này khác nhau đáng kể, thuật toán khám phá họa tiết có chiều dài không thể khám phá cả ba họa tiết trong một lần chạy. Ngược lại, cả ba họa tiết đều được thuật toán của chúng tôi tìm thấy chỉ với vài giây thời gian thực hiện. Công việc trước đây cũng lưu ý rằng các họa tiết có độ dài thay đổi là các tính năng có giá trị cho nhiều tác vụ khai thác dữ liệu chuỗi thời gian [30] [6] [18]. Hình 1: Các mô hình có độ dài khác nhau được thuật toán của chúng tôi phát hiện trong một đoạn dữ liệu từ [22]. Thách thức lớn nhất trong việc phát hiện các họa tiết có chiều dài thay đổi là khả năng mở rộng. Chúng tôi chứng minh vấn đề này bằng các họa tiết có độ dài từ 300 đến 10300 trong chuỗi thời gian mười triệu. Thuật toán brute force yêu cầu các cuộc gọi khoảng cách 5 × 1018 để giải quyết vấn đề này. Trong trường hợp này, độ phức tạp tính toán tương tự như mô-đun có chiều dài tăng dần trong chuỗi thời gian 1 tỷ. Nói cách khác, độ phức tạp tính toán của khám phá mô-đun có độ dài thay đổi lớn hơn 10 lần so với vấn đề khám phá mô-đun có độ dài lớn nhất hiện tại được giải quyết trong [32] (mất 12,13 ngày với tốc độ tăng tốc GPU). Kết quả là, mặc dù thuật toán tiên tiến có thể đạt được tỷ lệ cắt tỉa 95%, việc liệt kê các họa tiết từ độ dài 64 đến 1024 trong chuỗi thời gian EEG có độ dài 160.000 vẫn mất 16 giờ để hoàn thành [18]. Chuỗi thời gian hàng triệu quy mô tồn tại trong nhiều lĩnh vực. Ví dụ: bộ dữ liệu nhu cầu năng lượng 2 năm được sử dụng trong [22] có độ dài khoảng 7 triệu. Chuỗi thời gian EOG được ghi lại trong [7] có độ dài khoảng 8 triệu. Trong cả hai tập dữ liệu, các thuật toán hiện đại quá tốn kém để áp dụng. Một loạt các thuật toán khám phá mô-đun chuỗi thời gian có độ dài thay đổi gần đúng dựa trên cảm ứng ngữ pháp đã được giới thiệu [9] [26] sau một quá trình ba bước. Ở bước đầu tiên, chuỗi thời gian được chuyển đổi thành chuỗi chuỗi rời rạc thông qua cửa sổ trượt. Trong bước thứ hai, cảm ứng ngữ pháp (ví dụ: 
thông qua Sequitur [23]) được áp dụng trên chuỗi thời gian rời rạc để nhanh chóng phát hiện các chuỗi chuỗi lặp lại. Bước thứ ba ánh xạ các chuỗi lặp lại trở lại chuỗi thời gian mà chuỗi đại diện. Mặc dù khả năng mở rộng cho cách tiếp cận ngữ pháp tốt hơn đáng kể so với các thuật toán hiện đại, phạm vi chiều dài của họa tiết được phát hiện vẫn có thể bị giới hạn. Điều này là do các họa tiết dài thường bị phân tách thành các chuỗi chuỗi dài và không giống nhau một cách không cần thiết do lượng nhiễu cao trong dữ liệu và do cảm ứng ngữ pháp dựa trên kết hợp trình tự giống hệt nhau, các thuật toán dựa trên ngữ pháp hiện có các họa tiết dài khác nhau. Trong bài báo này, chúng tôi giới thiệu một thuật toán tham lam có tên là Phân cấp Motif dựa trên phân cấp (HIME) để phát hiện các họa tiết có độ dài thay đổi. Với chiều dài họa tiết tối thiểu l, HIME sẽ tự động tạo ra các họa tiết lớn hơn nhiều so với l dựa trên bảng ký hiệu ghi lại biểu diễn rời rạc của các chuỗi có độ dài thay đổi. Mặc dù thuật toán không phải là một thuật toán chính xác, nhưng trong các thử nghiệm, nó có thể tạo ra các họa tiết có độ dài từ 300 đến 3.000 trong một chuỗi thời gian dài hàng triệu, với thời gian thực hiện khoảng 1 phút. Điều này nhanh hơn đáng kể so với các thuật toán tiên tiến. Khả năng mở rộng tốt như vậy làm cho việc tìm kiếm các họa tiết có độ dài thay đổi trong chuỗi thời gian quy mô hàng triệu là một nhiệm vụ khả thi. Ngoài ra, so với các phương pháp tiếp cận phát hiện mô-đun dựa trên khớp lệnh như [9] [6], HIME làm tăng đáng kể phạm vi liệt kê mô-đun có thể được phát hiện. Tóm lại, công việc của chúng tôi có các tính năng độc đáo sau: • Nó có thể khám phá các họa tiết có phạm vi chiều dài lớn hơn nhiều mà các cách tiếp cận dựa trên trình tự [9] [6] không thành công. • Khả năng mở rộng tốt hơn đáng kể so với các thuật toán tiên tiến. Phần còn lại của bài báo được tổ chức như sau: Phần II thảo luận về công việc liên quan trong khám phá mô-đun có độ dài thay đổi và chiều dài thay đổi. Phần III giới thiệu định nghĩa và ký hiệu vấn đề được sử dụng trong bài viết này. Phần IV giới thiệu thuật toán HIME được đề xuất của chúng tôi. Cách tiếp cận lựa chọn tham số thích nghi được mô tả trong Phần V. Kết quả thử nghiệm được trình bày trong Phần VI và chúng tôi kết luận trong Phần VII. 
II. CÔNG VIỆC LIÊN QUAN Trong khi vấn đề phát hiện mô-đun chuỗi thời gian cổ điển tập trung vào việc phát triển các mẫu thường gặp nhất [12], phần lớn các nghiên cứu gần đây đã coi các họa tiết là cặp tiếp theo tương tự nhất (mà chúng tôi gọi là mô-đun cặp sau đây) [19] [19] [19] [ 20] [27] [10]. Ngoài ra, một số công việc nghiên cứu đã tập trung vào khám phá mô-đun gần đúng nhanh [5] [14]. Các mô típ được phát hiện bởi các thuật toán này có thể chứa các chuỗi con không thực sự giống nhau. Những chuỗi dương tính giả này có thể được loại bỏ trong quá trình xử lý hậu kỳ. Tương tự như vậy, các chuỗi tương tự có thể bị bỏ lỡ. Các tác giả trong [10] giới thiệu một thuật toán có tên QuickMotif, đạt được 3 bậc độ lớn tăng tốc so với thuật toán khám phá mô-đun có chiều dài truyền thống [20]. Trong một công trình gần đây, [31] giới thiệu một thuật toán bất cứ lúc nào được gọi là STAMP sử dụng tính tương tự nhanh 
thuật toán tìm kiếm [21] đến mô-đun chính xác của một chiều dài nhất định. Trong [32], các tác giả tiếp tục giới thiệu một thuật toán gọi là STOMP có thể giảm độ phức tạp thời gian của STAMP bằng O (log (N)). Trong [5], các tác giả sử dụng phép chiếu ngẫu nhiên để phát hiện các họa tiết gần đúng có chiều dài. Công việc trong [2] tập trung vào việc phát hiện các họa tiết gần đúng có chiều dài với bộ nhớ hạn chế. Một số công việc nghiên cứu gần đây đã tập trung vào các họa tiết có chiều dài thay đổi thường xuyên. Trong [24], các tác giả đã giới thiệu một thuật toán có tên là VLMD để tìm ra các họa tiết cặp K chính xác bằng cách gọi thuật toán khám phá mô-đun chính xác có độ dài xed (tức là MK [20]) với tất cả các độ dài có thể trong một phạm vi. Trong [18], các tác giả giới thiệu một thuật toán gọi là MOEN sử dụng phương pháp hạ thấp để tăng tốc quá trình liệt kê chiều dài họa tiết. Các tác phẩm khác như [16] [17] cũng theo ý tưởng tương tự của [18]. Tuy nhiên, một nhược điểm chung của các thuật toán này là tất cả chúng đều thực hiện một quy trình liệt kê gia tăng bắt đầu từ thesmallestlength.Since ﬁ ed xed -edmedifmalu đã rất tốn kém trong chuỗi thời gian quy mô lớn. Trong [9] [26], các tác giả giới thiệu một khung phát hiện mô-đun dựa trên ngữ pháp, sử dụng cảm ứng ngữ pháp để tìm ra các họa tiết gần đúng có độ dài thay đổi thông qua việc xác định các chuỗi rời rạc lặp đi lặp lại mà không liệt kê tất cả các độ dài có thể. Nó nhanh hơn đáng kể so với các thuật toán hiện có. Tuy nhiên, do ý tưởng của thuật toán dựa trên khớp chuỗi ký hiệu, nên phạm vi chiều dài của họa tiết được phát hiện có thể bị giới hạn đối với một số ứng dụng trong thế giới thực (ví dụ: cách tiếp cận không thể phát hiện các họa tiết được hiển thị trong Hình 1 trong một lần chạy). Các tác phẩm khác như [29] [4] cũng tập trung vào khám phá họa tiết có độ dài thay đổi; tuy nhiên, các kỹ thuật này có một số thiếu sót khiến chúng không hữu ích trong các trường hợp chung. Trong [29], các chuỗi con không được chuẩn hóa, điều này làm cho nó khác với các mẫu tương tự nhưng có biên độ khác nhau. Công việc được đề xuất trong [4] cũng bao gồm một bước rời rạc, nhưng các phần sau không chồng chéo. Kết quả là, nó không xem xét mọi ứng cử viên mẫu có thể, và do đó có thể bỏ lỡ một số mẫu thực sự [9] [26].
III. THÔNG BÁO & ĐỊNH NGH PRA VẤN ĐỀ Chúng tôi bắt đầu với các định nghĩa cơ bản liên quan đến chuỗi thời gian: Chuỗi thời gian T = t1, ..., tN là một tập hợp các quan sát theo thời gian. Kết quả sp, q của một serie thời gian T là tập hợp các điểm tiếp giáp trong chuỗi thời gian T bắt đầu từ vị trí p và kết thúc tại q với độ dài n = q - p + 1. Thông thường, n << N và 1 p N - n + 1. Kết quả có thể được trích xuất từ ​​T thông qua cửa sổ nghiêng. Trong nhiều ứng dụng, chúng tôi quan tâm đến việc phát triển các hình dạng tương tự như thế. Do đó, khám phá mô-đun có ý nghĩa hơn khi nó được bù và biên độ bất biến. Điều này có thể đạt được bằng cách bình thường hóa từng phần trước khi tìm kiếm họa tiết. chuẩn hóa z là một thủ tục bình thường hóa độ lệch trung bình và độ lệch chuẩn của lần sau về 0 và một, tương ứng. Cho một chuỗi thời gian T và một hàm khoảng cách D (.,.), Trong tác phẩm này, chúng ta định nghĩa một Motif chuỗi thời gian là một tập hợp 
các chuỗi con trong T sao cho khoảng cách giữa mỗi chuỗi con này và chuỗi hạt giống được gieo nhỏ hơn hàm ngưỡng mô-đun R (L), trong đó L là chiều dài của họa tiết được phát hiện, L ≥ l (chiều dài mô-đun tối thiểu). Mỗi phần tiếp theo trong một họa tiết được cho là một ví dụ của họa tiết. Thông tin cụ thể hơn, với chiều dài mô-đun tối thiểu l, các cặp thuật toán có độ dài L (L được thay đổi cho các cặp khác nhau), trong đó L l và mỗi cặp đều có định hướng mô-đun với ngưỡng R (L). Lưu ý rằng như đã đề cập trong [2], một khi cặp được phát hiện, tất cả các trường hợp mô-đun có thể được tìm thấy bằng cách sử dụng thuật toán truy vấn tương tự [21] [25]. A. Vấn đề Giảm khác với phát hiện mô-đun có độ dài xed, xác định một số đo chung (ví dụ: tần số hoặc độ tương tự) cho vấn đề phát hiện mô-đun bước sóng là không tầm thường [9] [24]. Ví dụ, một số họa tiết tần số thấp có thể thú vị hơn so với họa tiết tần số cao; một số họa tiết dài có thể có khoảng cách lớn so với các họa tiết ngắn ngay cả sau khi bình thường hóa theo chiều dài (ví dụ: Motif C so với Motif A trong Hình 1). Do phát hiện mô-đun có thể được sử dụng như một chương trình con cho các ứng dụng trong thế giới thực, thay vì xếp hạng các mô-đun dựa trên một số biện pháp quan tâm, thuật toán được đề xuất nhằm phát hiện hạt giống sau đó, với ít nhất một cặp con thỏa mãn ràng buộc mô-đun đã nêu ở trên. Người đọc có thể tham khảo [18] [30] [26] để biết chi tiết về các phương pháp đánh giá mô-đun khác nhau cho các mục tiêu khác nhau. Do hầu hết các cách tiếp cận hiện đại đều đánh giá các họa tiết về độ tương tự, nên khi so sánh với chúng trong phần thử nghiệm, chúng tôi bao gồm thời gian thực hiện xếp hạng các họa tiết dựa trên độ tương tự [20] [18].



Sự khác biệt của việc có được giải pháp chính xác cho họa tiết có độ dài thay đổi có thể được minh họa bằng một ví dụ đơn giản được hiển thị trong Hình 2. Giả sử hai trường hợp của một họa tiết, được hiển thị trong Hình 2 (b), xuất hiện trong một chuỗi thời gian (Hình 2 ( a)) tại vị trí thứ i và thứ j, tương ứng. Hình 2 (c) cho thấy sự tăng trưởng của Euclideandistancesbetweensub Hậu quả si, i + n − 1 và sj, j + n 1 cho tất cả các độ dài từ 2 đến 6000. Chúng ta có thể thấy từ Hình 2 (c) rằng sự tăng trưởng của khoảng cách là phi tuyến. Nghĩa là, khoảng cách giữa một cặp chuỗi ngắn không nhất thiết phải chia sẻ hành vi tương tự với khoảng cách giữa các chuỗi dài nếu chênh lệch độ dài lớn. Do đó, các thuật toán tiên tiến cần lặp lại thuật toán khám phá mô-đun có độ dài gấp nhiều lần trong quá trình liệt kê để tìm ra các họa tiết tối ưu, giúp tăng chi phí thời gian một cách đáng kể.
IV. PHƯƠNG PHÁP ĐỀ XUẤT Trong phần này, chúng tôi giới thiệu phương pháp đề xuất của chúng tôi. A. Phân biệt sự phân biệt chuỗi thời gian thành biểu diễn tượng trưng thường là một bước xử lý trước cần thiết cho khám phá mô-đun hiệu quả [11] [5] [26] [2]. Biểu tượng phê duyệt tổng hợp tượng trưng (SAX) [12], một kỹ thuật phân biệt được sử dụng rộng rãi để khai thác dữ liệu chuỗi thời gian. Đưa ra chuỗi thời gian chuẩn hóa z (một trường hợp tiếp theo trong trường hợp của chúng tôi), lần đầu tiên SAX chuyển đổi nó thành biểu diễn xấp xỉ tổng hợp (PAA) của Piecewise [11] về kích thước w (tức là các phân đoạn w). Sau đó, các hệ số PAA được ánh xạ tới các ký hiệu w với kích thước bảng chữ cái a theo bảng điểm dừng [12], được định nghĩa sao cho các vùng có thể xác định bằng nhau theo phân phối Gaussian. Những ký hiệu w tạo thành một từ SAX. Hình 3 minh họa quá trình rời rạc. Bảng điểm dừng được định trước [12] cho kích thước bảng chữ cái lên đến a = 5 được hiển thị trong Hình 3 (phía dưới).




B. Tính toán nhanh của SAX Vì các từ SAX được sử dụng rất nhiều trong thuật toán đề xuất, điều rất quan trọng là giảm chi phí thời gian của sự rời rạc. Chúng tôi giới thiệu một cách nhanh chóng để tính toán các từ SAX từ các chuỗi có độ dài khác nhau. Hai vectơ của các tính năng thống kê, Mx (x) = Px i = 1 ti và Mxx (x) = Px i = 1 t2 i được tính toán dựa trên chuỗi thời gian đầu vào T. Cho một chuỗi con Sp, q có độ dài n, SAX của nó biểu diễn có thể được tính toán bằng Thuật toán 1. Thuật toán sử dụng phương pháp tính toán PAA nhanh [10] [25] tocomputePAAcoef centswithtimecomplexity O (w) không phụ thuộc vào độ dài tiếp theo (Dòng 5-7). Trong Dòng 8, các hệ số PAA được chuyển đổi thành từ SAX dựa trên bảng điểm dừng được định trước, có giá O (wa). Do đó, chi phí của Thuật toán 1 là O (w + wa)). Do Mx (x), Mxx (x) canbecomputingduringpre sở hữu, nên chi phí tính toán một từ SAX cho độ dài tùy ý trong quá trình khám phá mô-đun là O (w + wa). Như đã trình bày trong [12], w và a nên rất nhỏ so với độ dài sau đó. Vì vậy, chi phí thời gian để tính toán một từ SAX được giảm từ O (n + wa) xuống O (w + wa) (w n). C. Giảm số lượng dựa trên giới hạn dưới Trong thực tế, các chuỗi lân cận tương tự nhau vì chúng bị lệch một điểm. Để giảm chi phí phát hiện các họa tiết dài, Giảm số lượng (NR) được sử dụng để tránh so sánh tương tự không cần thiết. Khác với Thuật toán 1 Tính toán SAX nhanh (FastSAX) 1: Đầu vào: Mx, Mxx, PAA kích thước w, sau đó Sp, q 2: Đầu ra: Đại diện PAA paa 3: Ex = Mx (q) −Mx (p), Exx = Mxx (q ) XxxMxx (p) 4: n = q p + 1, (paai, bắt đầu) n / w −
công việc trước đây [9] [6], trong đó một chuỗi con bị bỏ qua nếu biểu diễn SAX của nó giống hệt với lần ghi cuối cùng, chúng tôi sử dụng khoảng cách PAA để loại bỏ các chuỗi tương tự liên tiếp. Một chuỗi con được bỏ qua nếu khoảng cách PAA giới hạn thấp hơn giữa các chuỗi lân cận nhỏ hơn 2R (l). Vì chúng tôi muốn giới hạn dưới chặt chẽ, chúng tôi sử dụng kích thước PAA lớn. Trong công việc này, chúng tôi sử dụng kích thước PAA là 32 để giảm số lượng. D. Đồ thị cảm ứng

D. Đồ thị cảm ứng Hình 4: Minh họa đồ thị cảm ứng Số lượng từ SAX cần được kiểm tra để tạo thành các họa tiết dài có thể dài một cách không cần thiết nếu không sử dụng giảm số lượng. Xem hình 4 (trên cùng). Chuỗi thời gian được chuyển đổi thành một chuỗi các từ SAX: S1, S2, ..., S7. Nút thứ i trong biểu đồ biểu thị si tiếp theo, i + l 1 trong chuỗi thời gian. Không giảm số lượng, mỗi từ SAX / SAX duy nhất được giữ. Tuy nhiên, việc giảm số lượng có thể khiến một số mẫu bị bỏ qua do một số mẫu bị bỏ qua. Trong ví dụ hiển thị trong Hình 4 (giữa), S2, S4 và S5 bị bỏ qua do giảm số lượng và một số mẫu liên quan đến các chuỗi bị bỏ qua có thể bị bỏ qua. Để giảm thiểu nhược điểm của cả hai kịch bản, chúng tôi giới thiệu Biểu đồ cảm ứng (Hình 4 (dưới cùng)), cấu trúc biểu đồ giúp xác định thứ tự quét và liệt kê các ứng cử viên mô-đun trong quá trình khám phá mô-đun. Mỗi nút chứa 2 cạnh (cạnh tiếp theo và cạnh chuyển tiếp). Hai nút được kết nối bởi hai cạnh này được ký hiệu là Snext i và Sforward i (Trong hình 4 (phía dưới), đây là các mũi tên màu đen và màu vàng, tương ứng). Snext i là nút đại diện cho si tiếp theo + 1, i + l và Sforward i là chuỗi con không tương tự tiếp theo được xác định bằng cách giảm số lượng (xem phần trước). Biểu đồ cảm ứng có thể được lưu trữ bằng cách chỉ ghi các nút được kết nối bởi Sforward i. Ví dụ, trong Hình 4, tất cả các cạnh và nút trong Biểu đồ cảm ứng có thể được xây dựng lại nếu chúng ta ghi 4 nút: SNR = S1, S3, S6, S7. Trong phần còn lại của bài báo, các nút được kết nối theo hướng ngược lại của cạnh tiếp theo và cạnh chuyển tiếp được ký hiệu lần lượt là Sprev i và Sbackward i. 


E. Enifulation dựa trên phân cấp (HIME) Motif Enumutions dựa trên phân cấp (HIME) được mô tả trong Thuật toán 2. Theo trực giác, thuật toán tiến hành từ trái sang phải qua tất cả các nút thông qua cạnh tiếp theo trong Biểu đồ cảm ứng G. Với mỗi nút, thuật toán thực hiện đệ quy hai chức năng chính: Hồi quy đệ quy trực tuyến (Dòng 16-17) và Xóa RemoveCoveredMotif Hồi (Dòng 13). Trong bước RecursiveEnumutions, bước SAXwordsareformedtorepresentvariable và để phát hiện các chuỗi lặp lại. Loại bỏ ngay lập tức. Các họa tiết được phát hiện bởi thuật toán được lưu trữ trong Motifset (Dòng 12). Cuối cùng, xử lý hậu kỳ được áp dụng để loại bỏ các ứng cử viên họa tiết tầm thường và dương tính giả (Dòng 20). Lưu ý rằng HIME cũng có thể sử dụng giảm số lượng bằng cách chỉ kiểm tra các nút được ghi trong SNR của G.







Thuật toán 2 Bảng liệt kê Motif dựa trên phân cấp (HIME) 1: Đầu vào: Biểu đồ cảm ứng G 2: Tham số: PAA kích thước w, Alphabeta Kích thước a 3: Đầu ra: Motif Đặt Motifset 4: VLSAXTable [SAX word, length] [Location] = {} 5 : cho mỗi nút Si từ trái sang phải làm {Tính toán từ SAX cho chuỗi dài} 6: SS = Hợp nhất (Si, Sforward i); từ = FastSAX (SS, w, a); {Kiểm tra xem cùng một từ SAX đại diện cho một số thứ tự có độ dài tương tự được ghi lại} 7: if! VLSAXTable.exist (từ, SS.Lạng) sau đó 8: VLSAXTable.put (từ, SS.Lạng, SS.Location); 9: other {Truy xuất chuỗi con với từ SAX phù hợp} 10: SS2 = VLSAXTable.getSimL wavelSeq (word); {Cập nhật biểu đồ cảm ứng G} 11: insertMotifNode (G, SS2, SS); 12: UpdateMotifSet (Motifset, word); {Tham lam loại bỏ các động cơ được bảo hiểm} 13: RemoveCoveredMotif (SS, Si); {Liệt kê các Motif dựa trên SS và SS2} 14: SS3 = Hợp nhất (SS, SSforward); 15: SS4 = Hợp nhất (SS2, SS2); 16: Tính toán đệ quy (SS3); 17: Tính toán đệ quy (SS4); 18: kết thúc nếu 19: kết thúc trong 20: return RemoveTrivialAndFalsePostive (Motifset);
1) Phép liệt kê đệ quy dựa trên SAX: Trong bước này, Thuật toán 2 thực hiện đệ quy các dòng 6-18 để phát hiện các họa tiết có độ dài dao động. Đầu tiên, HIME tính toán một từ SAX và tạo ra một nút SS mới để biểu thị chuỗi dài có được bằng cách hợp nhất hai chuỗi ngắn Si và Sforward i (Dòng 6). Từ từ SAX mới, cùng với tổng độ dài của kết quả là kết quả cuối cùng được đưa vào bảng từ SAX, VLSAXTable, nếu cùng một từ SAX đại diện cho một số từ sau có độ dài tương tự 
không tồn tại trong bảng (Dòng 7-8). Nếu từ đã tồn tại trong VLSAXTable cho một số (các) chuỗi có độ dài tương tự, chúng tôi đã tìm thấy một mô-đun khớp. Thuật toán lấy SS2 dựa trên vị trí của chuỗi con phù hợp (Dòng 10) và chèn SS vào biểu đồ (Dòng 11). SS và SS2 hiện là một ví dụ của mô típ. Cạnh tiếp theo và cạnh chuyển tiếp của SS được cập nhật dựa trên cạnh tiếp theo và cạnh tiếp theo của Sforward i. Các liên kết ngược được kết nối tương ứng với Sbackward i và Sprev i. Việc chèn các nút mới cho phép chúng tôi sử dụng lại các họa tiết được phát hiện để giảm chi phí liệt kê các họa tiết dài. Sau đó, thuật toán kiểm tra đệ quy hai chuỗi dài được tạo mới được đại diện bởi SS3 và SS4 (được tạo bằng cách sáp nhập thêm SS với SSforward và SS2 với SS2forward, tương ứng) cho đến khi Dòng 7 là satis (ed 16-17). Chiến lược đệ quy tham lam như vậy có thể tạo ra một cấu trúc phân cấp thấp để phù hợp với các mẫu lặp lại dài [23]. 
Hình 5: Ví dụ cho thấy loại bỏ tham lam của họa tiết được che 2) Loại bỏ các họa tiết được che phủ: Một số họa tiết ngắn có thể hoàn toàn trùng lặp với các họa tiết dài. Như đã được chứng minh trong [24] [18], những họa tiết ngắn này (các họa tiết được phủ kín là che chở) là dư thừa. Vì vậy, trong quá trình liệt kê mô-đun, chúng tôi tiến hành một quy trình nhanh (Dòng 13) để xóa các mục nhập cho các họa tiết được bảo hiểm khỏi VLSAXTable và Motifset. Một ví dụ được hiển thị trong Hình 5 để minh họa quá trình. Cặp (từ, L) (ví dụ (ccaa, 50)) trong ure gure biểu thị từ từ SAX đại diện cho một chuỗi có độ dài L. Các chuỗi có cùng cặp (từ, L) là các trường hợp của cùng một mô típ ứng cử viên, và được dán nhãn cùng màu trong gure. Trong ví dụ, thuật toán đầu tiên mô-đun ngắn (Hình 5 (b)) dựa trên (ccaa, 50) (s30,80 khớp với s1100,1150). Thuật toán sau đó mở rộng s1100,1150 bằng cách sử dụng chiến lược liệt kê đệ quy được đề cập ở trên và hình thành một chuỗi dài hơn được biểu thị bởi (ccba, 80). Một trận đấu s30,110 cũng được tìm thấy (được dán nhãn màu xanh lục trong Hình 5 (c)). Vì (ccaa, 80) được tạo từ (ccaa, 50) và cả hai đều đại diện cho cùng một thứ tự (ngoại trừ một phiên bản dài hơn), tất cả các phiên bản của họa tiết được đại diện bởi (ccaa, 50) có thể trùng lặp với tất cả các trường hợp của họa tiết dài đại diện bởi (ccaa, 80). Do đó, thuật toán sẽ loại bỏ các chuỗi con được liên kết với (ccaa, 50) khỏi VLSAXTable và mô-đun ứng cử viên tương ứng khỏi bộ mô-đun (Hình. 
5 (d)). Trong khi đó, Remove RemoveCoveredMotif, không thể loại bỏ tất cả các họa tiết được bảo hiểm, nó được sử dụng để giảm thiểu thời gian và chi phí không gian trong quá trình khám phá mô-đun. Tất cả các họa tiết được bảo hiểm có thể được loại bỏ bằng thuật toán được mô tả trong [18] sau khi lấy bộ họa tiết. F. So với các phương pháp tiếp cận khám phá dựa trên sự phù hợp dựa trên trình tự so sánh theo trình tự So sánh với trình tự dựa trên SAX phù hợp với mô-đun khám phá gần đúng (ví dụ: [9] [6]), lợi thế của HIMEhastwounique. 

Hình 6: Một ví dụ cho thấy cách tiếp cận khác nhau đối với cách tiếp cận ngữ pháp đối với các họa tiết dài Thứ nhất, các cách tiếp cận hiện tại này chỉ có thể phát hiện một họa tiết dài nếu các chuỗi SAX đại diện cho các trường hợp mô-đun giống hệt nhau. Để minh họa sự khác biệt của việc tạo ra cùng một chuỗi cho mô-típ dài, một ví dụ được hiển thị trong Hình 6. Hai đoạn sau có độ dài 500 trong Hình 6 là các trường hợp mô-đun được phát hiện bởi thuật toán của chúng tôi trong chuỗi thời gian EPG [18]. Nếu chúng ta đặt độ dài tối thiểu là 50, hai chuỗi con này tạo thành hai chuỗi SAX có độ dài lần lượt là 27 và 33, với việc giảm số lượng. Rõ ràng, hai chuỗi sau được chuyển đổi thành chuỗi từ dài quá mức không giống nhau, ngoại trừ hai từ đầu tiên. Do đó, các cách tiếp cận dựa trên trình tự khớp có thể phát hiện ra chúng. Ngược lại, HIME sẽ tạo thành một từ SAX duy nhất cho mỗi lần tiếp theo thông qua quy trình liệt kê đệ quy và các họa tiết chỉ sử dụng từ SAX đại diện cho từ đó. Trong ví dụ này, vì hai phần sau thực sự có cùng đại diện SAX, HIME có khả năng khám phá chúng. Thứ hai, giá trị trung bình và phương sai của một chuỗi có thể ảnh hưởng đáng kể đến hình dạng [18]. Tuy nhiên, việc tạo ra các từ SAX trong chuỗi từ chỉ phụ thuộc vào giá trị trung bình và phương sai của chuỗi nhỏ. Do đó, khi độ dài của chuỗi từ dài, giá trị trung bình và phương sai của các chuỗi ngắn có thể khác biệt đáng kể so với trung bình và phương sai tổng thể của toàn bộ chuỗi. Vì vậy, ngay cả khi các chuỗi tương tự với nhau, chuỗi từ tương ứng của chúng có thể không giống nhau. HIME tránh được vấn đề này bằng cách tính lại nhanh từ SAX thông qua Thuật toán 1, giúp tái chuẩn hóa chuỗi sau mỗi lần. Trong các thí nghiệm, chúng tôi chứng minh rằng HIME tăng đáng kể phạm vi liệt kê so với các phương pháp tiếp cận dựa trên trình tự sắp xếp lại. 



Hình 7: Tính toán nhanh SAX V. LỰA CHỌN PARAMETER Vì hiệu suất của thuật toán phụ thuộc vào các tham số SAX w và a, để giảm bớt gánh nặng của việc lựa chọn tham số, chúng tôi giới thiệu một cách tiếp cận để chọn tham số thích ứng a. Trước tiên, chúng tôi giới thiệu một cách tiếp cận nhanh chóng để tính toán SAX đa biến với chi phí tương tự như SAX độ phân giải. Đưa ra kích thước bảng chữ cái tối đa, cách tiếp cận đầu tiên của chúng tôi tập hợp tất cả các điểm dừng SAX cho kích thước bảng chữ cái từ 2 đến amax. Đối với mỗi khoảng giữa hai điểm dừng bất kỳ, một chuỗi ký hiệu chứa các ký hiệu tương ứng lên đến độ phân giải amax được ghi lại. Một ví dụ với amax = 4 được hiển thị trong Hình 7. Các điểm dừng được biểu thị bằng cách x, x và chuỗi ký hiệu cho mỗi khoảng được hiển thị trong [.]. Bằng cách sử dụng tìm kiếm nhị phân để xác định khoảng thời gian mà hệ số PAA thuộc về, chúng ta có thể tìm ra các biểu diễn SAX của nó trong tất cả các độ phân giải từ 2 đến amax với chi phí thấp. Vì số lượng khoảng được ràng buộc bởi O (amax2), độ phức tạp thời gian của tìm kiếm nhị phân bị ràng buộc bởi O (2log (amax)). Lấy các giá trị PAA được ký hiệu là màu vàng làm ví dụ, thuật toán tính toán 3 độ phân giải khác nhau của các từ SAX aab, abc, abd bằng cách ghép ba chuỗi ký hiệu aaa, abb, bcd (hiển thị trong {.}). Xác định mỗi chuỗi ký hiệu chỉ mất 3 tìm kiếm nhị phân. Như đã đề cập trong [26], đối với khám phá mô-típ, thường được chọn dưới 20, chỉ chứa 128 điểm ngắt khác biệt. Vì vậy, sự phức tạp của việc tính toán một SAX đa độ phân giải duy nhất với kích thước PAA w word với tối đa 20 chỉ tốn O (1 + 7w).
Thuật toán lựa chọn tham số thích nghi được phác thảo trong Thuật toán 3. Thuật toán lấy mẫu ngẫu nhiên một cặp chuỗi (S1, S2) có độ dài l cho đến khi kích thước bảng chữ cái a được xác định. Đối với mỗi cặp được lấy mẫu, một mức phù hợp làm cho độ chặt của độ chặt giới hạn thấpB (được tính bằng SAXMINDIST (S1, S2) / EuclideanDist (S1, S2)) của từ SAX gần 0,5 được ghi lại. Ngưỡng (0,5) cung cấp một cách để cân bằng độ chặt của biểu diễn và số lượng từ SAX riêng biệt. Vì độ chặtLB tăng đơn điệu khi tăng [12], bằng cách sử dụng tìm kiếm nhị phân (Dòng 4-6), chúng tôi có thể tìm ra cách phù hợp mà không cần kiểm tra tất cả các độ phân giải. Theo trực giác, độ chặtLB kiểm soát hiệu suất gần đúng của các từ SAX và có thể được sử dụng để chọn độ phân giải phù hợp. Kích thước bảng chữ cái trung bình ¯ a được chọn là tham số cho thuật toán HIME sau khi thuật toán chọn tham số hội tụ (ví dụ: khi thay đổi a nhỏ hơn 0,01). Bằng cách tính toán trước các từ SAX của tất cả các độ phân giải cho
(S1, S2), BinarySearchResolution trong Thuật toán 3 chỉ tốn O (5) để tìm kiếm phù hợp từ 2 đến amax = 20. Trong quá trình thử nghiệm, ¯ a thường hội tụ sau một nghìn lần lấy mẫu, chỉ mất chưa đến một giây. Thuật toán 3 Xác định kích thước bảng chữ cái cho HIME 1: Đầu vào: Chuỗi thời gian T 2: Đầu ra: Kích thước bảng chữ cái a 3: trong khi ¯ a không hội tụ làm 4: Lấy mẫu ngẫu nhiên S1, S2 từ chuỗi thời gian T 5: ai = BinarySearchResolution (S1, S2 ); 6: a = Trung bình (a); 7: kết thúc trong khi 8: trả về a VI. KINH NGHIỆM ĐÁNH GIÁ Chúng tôi thực hiện một loạt các thí nghiệm để đánh giá hiệu suất của HIME. Tất cả các thử nghiệm được tiến hành trên máy tính xách tay RAM 16 GB với bộ xử lý lõi tứ 2,5 GHz. Phần mềm và bộ dữ liệu thực thi được sử dụng trong các thử nghiệm có thể được tìm thấy trong http://bit.ly/2rvBETV. Lưu ý rằng mục tiêu của các thử nghiệm là thể hiện sự đóng góp và các ứng dụng tiềm năng cho các họa tiết phát triển hiệu quả với sự khác biệt về chiều dài lớn mà các thuật toán hiện tại có thể có khác biệt. 
Chúng tôi thử nghiệm lần đầu tiên 2 phương pháp tiếp cận hiện đại khác nhau [24] [18] inthetaskofdetectingmotifsoflengthfrom 300 đến 2300 trong ba chuỗi thời gian thực trong thế giới thực với độ dài 160.000 để chứng minh vấn đề về khả năng mở rộng. Cách tiếp cận đầu tiên lặp đi lặp lại gọi thuật toán khám phá mô-đun có độ dài (ví dụ MK [20]) để tìm ra các chuỗi tương tự nhất ở các độ dài khác nhau [24]. Chúng tôi chọn thuật toán nhanh nhất hiện tại, QuickMotif [10], để tối đa hóa khả năng mở rộng của nó (ký hiệu là ItrQuickMoitf). Cách tiếp cận thứ hai [18] (MOEN) áp dụng thuật toán tìm kiếm tương tự cặp đôi và giới hạn dưới để cắt tỉa một số độ dài không cần phải kiểm tra. Chúng tôi chọn các thuật toán nhanh nhất, STOMP [32] và STAMP [31], được sử dụng với khung MOEN. Vì STAMP chậm hơn STOMP trong tất cả các trường hợp thử nghiệm, chúng tôi chỉ hiển thị thời gian thực hiện cho phép liệt kê mô-đun dựa trên STOMP (ký hiệu là MOENSTOMP). Tất cả thời gian thực hiện của STAMP và STOMP đều dựa trên mã C được cung cấp bởi các tác giả. Bảng I cho thấy thời gian thực hiện của thuật toán khám phá mô-đun có độ dài, MOEN (sử dụng mã do tác giả cung cấp) và thời gian thực hiện ước tính nếu Quick-Motif và STOMP được áp dụng theo cả hai cách tiếp cận liệt kê tương ứng (được tính dựa trên số lần được tính thuật toán -length được gọi trong khung). Từ kết quả, ItrQuick-Motif rất tốn kém so với khung MOEN. Mặc dù MOEN đạt tỷ lệ cắt tỉa 90%, 95% và 98% trong 3 bộ dữ liệu tương ứng, ngay cả khi sử dụng thuật toán so sánh tương tự tất cả các cặp mới nhất, MOEN-STOMP vẫn mất hàng giờ để phát hiện họa tiết. Ngược lại, HIME chỉ mất vài giây bao gồm cả xử lý hậu kỳ. Vì vậy, các thuật toán tiên tiến khó có thể được áp dụng trong các thử nghiệm còn lại do chuỗi thời gian nhỏ nhất được sử dụng có độ dài 1 triệu. Do đó, thay vì so sánh trực tiếp 
hiệu suất khả năng mở rộng, chúng tôi so sánh hiệu suất của chúng tôi với STOMP + tỷ lệ cắt tỉa 99%. Như thể hiện trong bảng, việc cắt tỉa 99% là khó đạt được ngay cả trong chuỗi thời gian ECG định kỳ. Tương tự như ItrQuick-Motif, trực tiếp sử dụng khám phá mô-đun gần đúng chiều dài xed [2] [5] [13] cũng rất tốn kém. Ví dụ: ngay cả khi thuật toán khám phá mô-đun gần đúng chỉ mất một giây đến các họa tiết có chiều dài gấp đôi, các họa tiết trong phạm vi độ dài [300, 2300] vẫn cần khoảng 33 phút. Trong chuỗi thời gian dài, chỉ riêng bước phân tách trong [5] [13] có thể mất hơn một giây. Vấn đề tương tự cũng tồn tại ở phiên bản dài bất kỳ của thuật toán khám phá mô-đun hiện đại, STAMP [31]. STAMP chỉ có thể kiểm tra ít hơn 50 trong số 16 triệu lần sau trong một giây. BẢNG I: Thời gian cần thiết để phát hiện các họa tiết có độ dài từ 300 đến 2300 trong chuỗi thời gian có độ dài 160.000. Một số lần chỉ là ước tính. Thuật toán / Bộ dữ liệu Điện năng EEG ECG STAMP (ﬁ xed) 12,15 phút 12 phút 13,7 phút STOMP (ﬁ xed) 4,15 phút 5,19 phút 4,05 phút Nhanh chóng (ﬁ xed) 8.2 phút 7,8 phút 30 giây. MOEN 3,1 ngày 1,7 ngày 16 giờ ItrQuick-Motif (est.) 11,3 ngày 10,08 ngày 16,6 giờ MOEN-STOMP (est.) 13,8 giờ 8,65 giờ HIME + Xử lý sau 23 giây 21 giây được đặt bằng Thuật toán 3. Kích thước PAA w được đặt thành 6. Độ dài tối thiểu l là 300 và ngưỡng họa tiết là R (L) = 0,02L. Mối quan hệ giữa thời gian thực hiện, phạm vi liệt kê và cài đặt tham số được thảo luận trong Sec VI.C. 
A. Phát hiện các mô hình được trồng trong chuỗi thời gian đi bộ ngẫu nhiên Chúng tôi thử nghiệm HIME đầu tiên trong một thử nghiệm mô-đun được trồng để chứng minh khả năng phát hiện các họa tiết với độ chính xác cao. Chúng tôi chọn thuật toán phát hiện mô-đun dựa trên ngữ pháp (Sequitur) [9] làm cơ sở vì nó có thể tìm thấy các họa tiết có độ dài thay đổi trong chuỗi thời gian hàng triệu và sử dụng quy trình nhận dạng phân cấp tương tự như thuật toán đề xuất. Chúng tôi đã trồng 4 họa tiết có độ dài khác nhau, mỗi mẫu 10 cái, thành một chuỗi thời gian đi bộ ngẫu nhiên có chiều dài 3 triệu. Xác suất mà một ví dụ của themotifappearsinthetimeseriesissmallerthan 10−5, có thể được coi là mô-típ hiếm [2]). Hình dạng của họa tiết được tạo ra bằng cách sử dụng x = P5 i = 1 Ai sinαix + i với các tham số ngẫu nhiên Ai [0,5], αi ∈ [2,2] và βi ∈ [−π, π]. Độ dài của họa tiết LM là 1500,3000,6000,12000. Chúng tôi đã thêm 5% nhiễu ngẫu nhiên cho mọi trường hợp của họa tiết. Giá trị trung bình và phương sai cũng được tạo ngẫu nhiên. HIME dự kiến ​​sẽ tìm thấy ít nhất một cặp các chuỗi con không chồng lấp cho mỗi mô-đun trùng lặp cao với các trường hợp được trồng thực tế. Hiệu suất của cả hai thuật toán được đo bằng tỷ lệ chồng chéo giữa các vị trí tìm thấy và vị trí sự thật mặt đất. Do thuật toán dựa trên ngữ pháp cũng tạo ra các họa tiết dựa trên chuỗi từ SAX rời rạc, chúng tôi tiến hành tìm kiếm lưới để lựa chọn tham số a = 3,4,5,7 và w = 4,5,7 (bao phủ khu vực tìm kiếm lưới được đề cập trong [6]) và chỉ báo cáo hiệu suất tốt nhất.

Hình 8: Tốc độ chồng lấp so với Sequitur để phát hiện các họa tiết được trồng có độ dài khác nhau Kết quả thử nghiệm được thể hiện trong Hình 8. Đối với Sequitur, tốc độ chồng lấp tốt nhất (trung bình 0,45) đạt được khi LM = 1500. Đối với tất cả các độ dài họa tiết khác , tỷ lệ chồng chéo là giữa 0,1 và 0,3. Ngược lại, HIME luôn có tỷ lệ chồng lấp trên 0,8 cho chiều dài họa tiết 1500, 3000 và 6000. Hiệu suất giảm khi phát hiện họa tiết có độ dài 12000; tuy nhiên, HIME vẫn có thể đạt được tỷ lệ chồng lấp trên 0,8 trong 6 trên 10 trường hợp cho chiều dài họa tiết 12000. Hình 9: Tỷ lệ chồng lấp so với số lượng phiên bản họa tiết cho chiều dài họa tiết 6000 
1) Hiệu suất VS. Số lượng trường hợp: Chúng tôi đã tiến hành một thử nghiệm để minh họa mối quan hệ giữa độ chính xác và số lượng phiên bản được lặp lại trên chuỗi thời gian. Chúng tôi sử dụng mô-đun trồng có chiều dài 6000 và điều chỉnh số lượng phiên bản trong mỗi thử nghiệm. Tỷ lệ chồng lấp so với số lượng phiên bản được lặp lại được hiển thị trong Hình 9. Theo Hình 9, độ chính xác tăng nhanh khi số lượng phiên bản lặp lại tăng lên. Thuật toán có thể phát hiện thành công các họa tiết được trồng với tỷ lệ chồng chéo rất cao (trên 80% trùng với sự thật mặt đất) khi số lượng phiên bản trên 6. Lưu ý rằng một họa tiết chỉ lặp lại 6 lần trong chuỗi triệu thời gian được coi là một họa tiết hiếm gặp đến độ dài của chuỗi thời gian. Do đó, mặc dù HIME là thuật toán phát hiện mô-đun gần đúng tham lam không đảm bảo giải pháp chính xác, vì thuật toán sử dụng tất cả các chuỗi ngắn chồng chéo với các phiên bản để phát hiện họa tiết dài, khả năng phát hiện họa tiết tăng lên khi số lượng mô-đun tăng. Ngoài ra, các họa tiết thường lặp lại nhiều lần trong một chuỗi thời gian dài (ví dụ: nếu một họa tiết xuất hiện với xác suất 10−4, trong một chuỗi thời gian có độ dài một triệu, nó có thể xuất hiện 100 lần), do đó, cơ hội của họa tiết là được phát hiện bởi HIME là cao. B. Khả năng mở rộng Trong tiểu mục này, khả năng mở rộng của thuật toán được kiểm tra trong chuỗi thời gian đi bộ ngẫu nhiên dài 16 triệu. 1) Thời gian thực hiện Vs. Kích thước dữ liệu: Chúng tôi sử dụng STOMP [31] với tỷ lệ cắt tỉa 99% để chứng minh sự cần thiết của một

BẢNG II: Khả năng mở rộng so với Giải pháp tiên tiến ước tính (không giảm số lượng) 












(b) Tham số Vs. Phạm vi liệt kê Hình 10: Các thí nghiệm tham số trong chuỗi thời gian đi bộ ngẫu nhiên theo cách tiếp cận gần đúng trong chuỗi thời gian hàng triệu (hoặc lớn hơn). Trong trường hợp thử nghiệm khi STOMP mất hơn 24 giờ, chúng tôi ước tính thời gian thực hiện theo 100 lần lặp đầu tiên (cách tiếp cận ước tính tương tự được sử dụng trong [31]). Phạm vi liệt kê của HIME được đo sau khi loại bỏ tất cả các họa tiết dương tính giả dựa trên chức năng ngưỡng họa tiết. Kết quả được thể hiện trong Bảng II. Thời gian hoạt động của HIME tăng chậm hơn đáng kể so với các thuật toán tiên tiến nhất. Trong trường hợp thử nghiệm lớn nhất, HIME mất khoảng 2,5 giờ để xử lý 16 triệu lần sau và phạm vi chiều dài của họa tiết được tìm thấy là từ 300 đến 10795. Thời gian thực hiện ước tính cho STOMP là 68 ngày. Vì vậy, ngay cả với tỷ lệ cắt tỉa 99%, có thể mất 20 năm để liệt kê phạm vi độ dài tương tự như HIME (mặc dù đối với STOMP, giải pháp sẽ chính xác). Lưu ý rằng GPU 

phiên bản STOMP [32], có thể đạt tốc độ tăng tốc khoảng 150 lần, có thể được sử dụng để tăng khả năng mở rộng của STOMP. Tuy nhiên, nó vẫn có thể mất 47 ngày. Kích thước bài toán đơn giản là quá lớn đối với các thuật toán tiên tiến để có được giải pháp chính xác. Ngược lại, HIME cung cấp một cách khác để phát hiện thường xuyên các họa tiết có độ dài thay đổi gần đúng của phạm vi chiều dài lớn trong thang thời gian này. 2) Phạm vi liệt kê Vs. Kích thước dữ liệu: Tiếp theo chúng tôi chứng minh rằng HIME có thể phát hiện các họa tiết trong phạm vi liệt kê lớn khi độ dài của chuỗi thời gian tăng lên. Hiệu suất được so sánh với Sequitur (phương pháp dựa trên ngữ pháp). Tương tự như thử nghiệm trước đây, chúng tôi sử dụng tìm kiếm dạng lưới để tìm ra các tham số tốt nhất cho Sequitur để phạm vi liệt kê có thể được tối đa hóa. Để so sánh công bằng, HIME sử dụng chiến lược giảm số lượng tương tự như Sequitur trong thí nghiệm này thay vì phương pháp Biểu đồ cảm ứng được giới thiệu trong Phần IV.D. Bằng cách này, cả hai thuật toán xử lý cùng một đầu vào. Các kết quả được thể hiện trong Bảng III. Phạm vi liệt kê Sequitur sắp ngừng tăng sau khi đạt độ dài 886. Ngược lại, phạm vi liệt kê HIME sườn tiếp tục tăng khi độ dài chuỗi thời gian tăng lên. Do đó, trong chuỗi thời gian quy mô lớn, HIME có thể phát hiện các họa tiết dài hơn đáng kể so với Sequitur. Khi độ dài của chuỗi thời gian đạt 16 triệu, phạm vi liệt kê của HIME là một bậc lớn hơn so với Sequitur. Chúng tôi cũng đo thời gian thực hiện của cả hai thuật toán bao gồm xử lý hậu kỳ. Theo kết quả, thời gian chạy tổng thể của HIME, chậm hơn so với Sequitur. Tuy nhiên, xét đến phạm vi liệt kê HIME, lớn hơn 4-15 lần so với Sequitur, thì HIME hiệu quả hơn Sequitur trên mỗi chiều dài liệt kê mô-đun.



C. Phân tích tham số Trong tiểu mục này, chúng tôi chứng minh rằng các tham số trong HIME rất dễ chọn. Hãy nhớ lại rằng Thuật toán 3 có thể giúp xác định kích thước bảng chữ cái cho một phạm vi, vì vậy chúng ta chỉ cần đặt một tham số cho HIME. Chúng tôi kiểm tra HIME với tham số w từ 4 đến 16 và từ 5 đến 15 trên chuỗi thời gian đi bộ ngẫu nhiên dài 1 triệu. Thời gian thực hiện và phạm vi liệt kê của tất cả các kết hợp tham số được hiển thị trong Hình 10 (a) và Hình 10 (b) tương ứng. Theo hình 10, thời gian thực hiện và phạm vi liệt kê của HIME trong khi tăng và giảm. Điều này là do w nhỏ và cho phép kết hợp từ dễ dàng hơn, nhưng biểu diễn lỏng lẻo  cũng yêu cầu thuật toán phải mất thêm thời gian để so sánh và lọc ra các kết quả dương tính giả. Khi số lượng từ SAX riêng biệt tăng theo mức tăng của w và a, thời gian thực hiện và phạm vi liệt kê của thuật toán sẽ giảm. Kết hợp tham số được chọn bởi Thuật toán 3 cho các w khác nhau được dán nhãn màu đỏ trong ure gure. Theo ure gure, Thuật toán 3 có xu hướng chọn một sự đánh đổi thời gian thực hiện và phạm vi liệt kê với mức độ ưu tiên như nhau. Bằng cách sử dụng Thuật toán 3 để xác định a, sự thay đổi về thời gian thực hiện và phạm vi liệt kê khi tăng w giống như kết quả từ việc đặt 2 tham số. Vì vậy, người dùng chỉ có thể chọn w trừ khi họ muốn liệt kê một phạm vi độ dài lớn hoặc tiết kiệm chi phí thời gian do độ dài của chuỗi thời gian. Trong những trường hợp này, người dùng có thể đặt cả tham số w và a để cân bằng phạm vi liệt kê và thời gian thực hiện. 

D. Nghiên cứu trường hợp Trong phần này, chúng tôi cho thấy HIME có thể tìm thấy các họa tiết chất lượng cao trong một số dữ liệu chuỗi thời gian thực trên thế giới triệu. Như đã trình bày trong phần trước, các thuật toán hiện có quá tốn kém để được áp dụng cho các vấn đề ở quy mô như vậy. 1) Biến đổi độ dàiSimilarSub resultencesDiscoveryinDNA Trình tự: Như đã trình bày trong công việc trước đây, chuyển đổi chuỗi DNA thành chuỗi thời gian [25] có thể giúp các nhà nghiên cứu hiểu được sự tương đồng về cấu trúc [32] [25] giữa các chuỗi DNA. Trong trường hợp nghiên cứu này, chúng tôi sử dụng HIME để lặp lại các chuỗi con trong nhiễm sắc thể của con người. Chúng tôi chuyển đổi hgY thành chuỗi thời gian 26 triệu dựa trên thuật toán được mô tả trong [25]. Chúng tôi đặt kích thước PAA w thành 10 để thuật toán có thể kết thúc quá trình tìm kiếm trong vòng nửa giờ. Chúng tôi đặt chiều dài họa tiết tối thiểu l đến 1000. Đường cong mật độ họa tiết [26] được hiển thị trong Hình 11.top. Chúng tôi quan sát một khu vực có một lượng lớn các tiểu phân lặp đi lặp lại. Theo từ [28], vùng khuếch đại này, vùng này có nhãn màu đỏ (được dán nhãn màu đỏ) trong nhiễm sắc thể Y. Như đã giải thích trong [28], vùng khuếch đại, hay đoạn phân đoạn khuếch đại, bao gồm phần lớn các chuỗi thể hiện sự tương đồng rõ rệt đến 99,9% bản sắc so với hàng chục hoặc hàng trăm kilobasesto các chuỗi khác trong MSY tựa



Hai ví dụ về họa tiết dài được phát hiện bởi thuật toán của chúng tôi được hiển thị trong Hình 11.bottom. Hai họa tiết được tìm thấy cho thấy sự tương đồng giữa 2 chuỗi DNA dài có chiều dài lần lượt là 18.000 và 22.000. Lưu ý rằng công việc trước đây [28] đặt cửa sổ trượt có độ dài 2000 đến mẫu thứ tự DNA tương tự.Weshowthe ﬁ rst2000pointofthelongmotifsinthe hộp đen. Khoảng cách bên trong tương ứng giữa cả hai cặp subseqeunces lớn hơn ngưỡng mô-đun. Nói cách khác, chúng sẽ không được phát hiện bằng thuật toán khám phá mô-đun có độ dài bằng chiều dài 2000. Thử nghiệm chỉ ra rằng, bằng cách cho phép phát hiện mô-đun có độ dài thay đổi trong chuỗi thời gian dài, HIME cung cấp cơ hội để khám phá các mẫu có khả năng gây ngạc nhiên khó có thể gây ra. để được phát hiện. 2) Khám phá các họa tiết trong Nhạc phim Chim: Tác phẩm hiện có [2] [27] cho thấy các họa tiết có thể được sử dụng để tìm các cuộc gọi lặp lại từ nhạc phim chim. Trong thí nghiệm này, chúng tôi đã thử nghiệm phương pháp của chúng tôi với 600 hồ sơ về các loài chim spinetail Rufours Capped, Spix và Azard trong [1]. Chúng tôi sử dụng hệ số Mel-Tần số thứ hai





Hình 11: Ví dụ về các họa tiết chuỗi thời gian được tìm thấy trong YChromosome của con người (MFCC) với 250 Hz để tạo thành chuỗi thời gian dài 5 triệu. HIME được áp dụng cho chuỗi thời gian này với độ dài tối thiểu bằng 0,5 giây. 










Hình 12: Ví dụ về các họa tiết được HIME phát hiện trong Soundtrack Bird Ba ví dụ về các họa tiết được phát hiện trong 3,4, 2.0 và 4,5 giây được hiển thị trong Hình 12. Bằng cách sử dụng thuật toán truy vấn [21] để lấy tất cả các trường hợp họa tiết từ cặp gần nhất được phát hiện , chúng tôi thấy rằng các phần sau tương tự của ba họa tiết này đề cập đến cùng một loài chim. Bốn bản ghi của mỗi loài chim được hiển thị trong Hình 12.right. Các vị trí của các họa tiết được dán nhãn màu đỏ. 3 họa tiết này cũng giải thích một số mẫu âm thanh độc đáo cho mỗi con chim. Ví dụ, Hình 12 (a) cho thấy Rufous Capped có thể im lặng 1,5 giây sau tiếng chim kêu. Hình 12 (b) cho thấy rằng giữa mỗi cuộc gọi của Spix Spinetail, nó có xu hướng có 0,5 giây. lỗ hổng. Hình 12 (c) chỉ ra rằng Azard Spinetail thường tạo ra ba cuộc gọi chim liên tiếp. Thông tin như vậy cung cấp những hiểu biết hữu ích có thể giúp các nhà nghiên cứu hiểu hành vi của chim. 3) Tiết lộ các mẫu hiếm trong chuỗi thời gian sử dụng năng lượng điện dài: Trong nghiên cứu trường hợp này, chúng tôi cho thấy rằng bằng cách cho phép phát hiện mô-đun lớn, HIME có thể phát hiện các mẫu dài và hiếm trong chuỗi thời gian thực. HIME được áp dụng trên chuỗi thời gian sử dụng năng lượng điện của tủ đông dài 7,4 triệu được ghi trong [22] với độ dài tối thiểu xấp xỉ bằng 1 giờ. Một ví dụ về mẫu dài được hiển thị trong Hình 13. HIME phát hiện các chuỗi lặp lại được hiển thị trong Hình 13 (trên cùng, giữa; khoảng 10 giờ). Sử dụng thuật toán truy vấn [21], chúng tôi thậm chí là lần thứ hai tương tự




 